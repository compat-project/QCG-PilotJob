import json

from enum import Enum
import logging

from qcg.pilotjob.allocation import CRAllocation, CRBindAllocation, NodeAllocation
from qcg.pilotjob.errors import InternalError, NotSufficientResources


_logger = logging.getLogger(__name__)


class CRType(Enum):
    """Consumable resource type."""

    GPU = 1
    MEM = 2


class CR:
    """Consumable resources.

    Attributes:
        crtype (CRType): type of cr
        total_count (int): number of cr
        used (int): currently used crs
    """

    def __init__(self, crtype, total_count=0, used=0):
        """Initialize consumable resources.

        Args:
            crtype (CRType): type of cr
            total_count (int): number of crs
            used (int): currently used crs
        """
        self.crtype = crtype
        self.total_count = total_count
        self.used = used

    @property
    def available(self):
        """int: number of available resources."""
        return self.total_count - self.used

    def allocate(self, count):
        """Allocate consumable resources.

        Args:
            count (int) - number of consumable resources to allocate

        Returns:
            CRAllocation: number of allocated resources, or 0 if no resources has been allocated - due to
                insufficient resources.
        """
        if count <= self.available:
            self.used += count
            return CRAllocation(self.crtype, count)

        return None

    def to_dict(self):
        """Serialize consumable resources to dictionary.

        Returns:
            dict: serialized consumable resources
        """
        return {'type': self.crtype.name, 'total': self.total_count, 'used': self.used}

    @staticmethod
    def from_dict(data):
        """Create instance of CR class based on serialized data.

        Args:
            data (dict): node data generated by the 'to_dict' method

        Returns:
            CR: instance
        """
        return CR(CRType[data['type']], data['total'], data['used'])

    def release(self, cralloc):
        """Release allocated consumable resources.

        Args:
            cralloc (CRAllocation) - allocation to release

        Raises:
            InternalError: if allocation size is greater than used resources, no resources are released.
        """
        if not isinstance(cralloc, CRAllocation):
            raise InternalError("failed type of CR allocation - {} vs expected CRAllocation".format(
                type(cralloc).__name__))

        if cralloc.count > self.used:
            raise InternalError("failed to release more resources {} than is allocated {} (CR {})".format(
                cralloc.count, self.used, self.crtype.name))

        self.used -= cralloc.count


class CRBind:
    """Consumable resource with bindable instances.

    The object tracks allocation of specific instances.

    Attributes:
        crtype (CRType) - type of CR
        total_count (int) - total number of available crs
        ids (list(str)) - list of all available instances
        _free (list(str)) - list of unused instances
    """

    def __init__(self, crtype, ids, free_ids=None):
        """Initialize bindable consumable resources.

        Args:
            crtype (CRType) - type of CR
            ids (list()) - all available instances
            free_ids (list, optional) - list of used instances
        """
        self.crtype = crtype
        self.total_count = len(ids)
        self.ids = list(ids)

        if free_ids:
            self._free = list(free_ids)
        else:
            self._free = list(ids)

    @property
    def available(self):
        """int: number of available resources."""
        return len(self._free)

    @property
    def used(self):
        """int: number of used resources."""
        return self.total_count - self.available

    def allocate(self, count):
        """Allocate bindable resources.

        Args:
            count (int): number of resources to allocate

        Returns:
            CRBindAllocation: object with a list of allocated bindable instances of the resources, or None if no
                resources has been allocated - due to insufficient resources.
        """
        if count <= self.available:
            allocation = CRBindAllocation(self.crtype, self._free[0:count])
            self._free = self._free[count:]
            return allocation

        return None

    def release(self, cralloc):
        """Release allocated bindable consumable resources.

        Args:
            cralloc (CRBindAllocation): allocation to release

        Raises:
            InternalError: if 'count' is greater than used resources, no resources are released.
        """
        if not isinstance(cralloc, CRBindAllocation):
            raise InternalError("failed type of CR allocation - {} vs expected CRBindAllocation".format(
                type(cralloc).__name__))

        if cralloc.count > self.used:
            raise InternalError("failed to release more resources {} than is allocated {} (CR {})".format(
                cralloc.count, self.used, self.crtype.name))

        self._free = sorted(self._free + cralloc.instances)

    def to_dict(self):
        """Serialize bindable consumable resources to dictionary.

        Returns:
            dict: serialized data
        """
        return {'type': self.crtype.name, 'ids': self.ids, 'free': self._free}

    @staticmethod
    def from_dict(data):
        """Create instance of CRBind class based on serialized data.

        Args:
            data (dict): serialized data

        Returns:
            CRBind: instance
        """
        return CRBind(CRType[data['type']], data['ids'], data['free'])


class Node:
    """
    Node resources.
    This class stores and allocates specific cores. Each core is identified by the number.

    Attributes:
        _name (str): node name
        _total_cores (int): total number of cores on a node
        _core_ids (list(str)): core identifiers
        _free_cores (list(str)): free core identifiers
        _crs (dict(crType,CR|CRBind)): list of available consumable resources
        resources (Resources): instance of resources the node belongs, set by constructor of Resources class
    """

    def __init__(self, name=None, total_cores=0, used=0, core_ids=None, free_cores=None, crs=None):
        """
        Args:
            name (str) - name of the node
            total_cores (int) - total number of available cores
            used (int) - initial number of used cores
            core_ids (list(str)) - optional core identifiers (the list must have at least 'total_cores' elements)
            free_cores (list(str)) - optional free core identifiers (the list must have total_cores-used elements)
            crs (dict(CRType,CR|CRBind)) - optional consumable resources
        """
        self._name = name
        self._total_cores = total_cores

        if core_ids:
            self._core_ids = core_ids
        else:
            self._core_ids = list([str(cid) for cid in  range(self._total_cores)])

        if free_cores:
            self._free_cores = free_cores
        else:
            self._free_cores = list(self._core_ids[used:total_cores])

        self._crs = crs
        self.resources = None

        self._available = True

    @property
    def name(self):
        """str: node name"""
        return self._name

    @property
    def total(self):
        """int: total number of cores"""
        return self._total_cores

    @property
    def used(self):
        """int: number of used cores"""
        return self._total_cores - len(self._free_cores)

    @property
    def free(self):
        """int: number of free cores"""
        return len(self._free_cores)

    @property
    def free_ids(self):
        """list(str): list of free core identifiers"""
        return self._free_cores

    @property
    def ids(self):
        """list(str): list of all available core identifiers"""
        return self._core_ids

    @property
    def crs(self):
        """dict(crType,CR|CRBind): available consumable resources"""
        return self._crs

    @property
    def str_crs(self):
        """str: string representation of available consumable resources"""
        return ', '.join(['{} - {} ({} used))'.format(crtype.name, cr.totalCount, cr.used) for crtype, cr in
                          self._crs.items()])

    @property
    def available(self):
        return self._available

    @available.setter
    def available(self, avail_value):
        if self._available and not avail_value:
            self.resources.mark_not_available_cores(self.free)
        elif not self._available and avail_value:
            self.resources.mark_available_cores(self.free)

        self._available = avail_value

    def __str__(self):
        """Return string representation of a node.

        Returns:
            str: string representation of a node
        """
        return '{} {} ({} used){}'.format(self.name, self.total, self.used,
                                          ', CR ({})'.format(self.str_crs) if self.crs else '')

    def has_enough_crs(self, crs):
        """Check if node has enough CR.

        Args:
            crs (dict(CRType,int)) - requested cr's specification

        Returns:
            true - if node contains requested cr's, otherwise false.
        """
        return all((self.crs,
                    all([cr in self.crs for cr in crs]),
                    all([v <= self._crs[cr].available for cr, v in crs.items()])))

    def allocate_crs(self, crs):
        """Allocate requested crs.

        Args:
            crs (dict(CRType,int)) - requested cr's specification

        Returns:
            dict(CRType,CR|CRBind) - with allocated cr's

        Raises:
            NotSufficientResources - if no all resources could be reserved, in that case no resources will be allocated.
        """
        if crs:
            cr_map = dict()

            try:
                for cr, count in crs.items():
                    cr_alloc = self._crs[cr].allocate(count)
                    if not cr_alloc:
                        self._crs[cr].release(cr_alloc)
                        raise NotSufficientResources("failed to allocate {} resources @ {} node ({} requested vs {} "
                                                     "available)".format(cr.name, self._name, count,
                                                                         self._crs[cr].available))

                    cr_map[cr] = cr_alloc
            except Exception:
                for crtype, cr in cr_map.items():
                    self._crs[crtype].release(cr)
                raise

            return cr_map

        return None

    def allocate_max(self, max_cores, crs=None):
        """Allocate maximum number of cores on a node and specific number of consumable resources.

        Args:
            max_cores (int) - maximum number of cores to allocate
            crs (dict(CRType,int), optional) - specific number of consumable resources

        Returns:
            NodeAllocation: instance with allocated resources, or None if there no any available resources
        """
        if crs:
            # make sure there is enough cr's on the node
            if not self.has_enough_crs(crs):
                return None

        nallocated = min(max_cores, self.free)
        if nallocated > 0:
            allocation = self._free_cores[0:nallocated]
            self._free_cores = self._free_cores[nallocated:]

            if self.resources is not None:
                self.resources.node_cores_allocated(len(allocation))

            return NodeAllocation(self, allocation, crs=self.allocate_crs(crs))

        return None

    def allocate_exact(self, cores, crs=None):
        """Allocate specific number of cores on a node and specific number of consumable resources.

        Args:
            cores (int) - requested number of cores to allocate
            crs (dict(CRType,int)) - optional specific number of consumable resources

        Returns:
            NodeAllocation: instance with allocated resources, or None if there no any available resources
        """
        if cores > 0:
            if crs:
                # make sure there is enough cr's on the node
                if not self.has_enough_crs(crs):
                    return None

            if cores <= self.free:
                allocation = self._free_cores[0:cores]
                self._free_cores = self._free_cores[cores:]

                if self.resources is not None:
                    self.resources.node_cores_allocated(len(allocation))

                return NodeAllocation(self, allocation, crs=self.allocate_crs(crs))

        return None

    def release(self, allocation):
        """Release allocation on a node.

        Args:
            allocation (NodeAllocation): allocated resources
        """
        if allocation.ncores > self.used:
            raise InternalError('trying to release more cores than are used on node {}'.format(self._name))

        self._free_cores = sorted(self._free_cores + allocation.cores, key=lambda c: int(c.split(',')[0]) if ',' in str(c) else int(c))

        if allocation.crs:
            if not self._crs:
                raise InternalError('trying to release crs which are not available on node {}'.format(self._name))

            for crtype, cr_bind in allocation.crs.items():
                if crtype not in self._crs:
                    raise InternalError('CR {} not available on a node {}'.format(crtype.name, self._name))

                self._crs[crtype].release(cr_bind)

        if self.resources is not None:
            self.resources.node_cores_released(allocation.ncores)

    def to_dict(self):
        """Serialize node information to dictionary.

        Returns:
            dict: serialized node informations
        """
        return {'name': self._name,
                'total_cores': self._total_cores,
                'core_ids': list(self._core_ids),
                'free_cores': list(self._free_cores),
                'crs': {crtype.name: {'class': cr.__class__.__name__, 'data': cr.to_dict()} for crtype, cr in
                        self._crs.items()} if self._crs else None}

    def to_json(self):
        """Serialize node information to JSON format.

        Returns:
            str: serialized node information
        """
        return json.dumps(self.to_dict())

    @staticmethod
    def from_dict(data):
        """Create instance of Node class based on serialized data.

        Args:
            data: node data generated by the 'to_dict' method

        Returns:
            Node: instance of Node class
        """
        return Node(data['name'],
                    data['total_cores'],
                    data['total_cores'] - len(data['free_cores']),
                    data['core_ids'],
                    data['free_cores'],
                    {CRType[crtype]: globals()[cr['class']].from_dict(cr['data']) for crtype, cr in
                     data['crs'].items()} if data['crs'] else None)


class ResourcesType(Enum):
    """Origin of resources."""
    LOCAL = 1
    SLURM = 2


class Resources:
    """Available resources set.
    The set stores and tracks nodes with possible different number of available cores.

    Attributes:
        _type (ResourcesType): origin of resources
        _binding (bool): does information about specific cores is available
        _nodes (list(Node)): list of available nodes
        _total_cores (int): total number of available cores
        _used_cores (int): currently used cores
        _max_crs (dict(CRType, int)): maximum number of consumable resources on single node
        _total_crs (dict(CRType, int)): total number of consumable resources
        _system_allocation (NodeAllocation): resources allocated for system, excluded from those available for jobs
    """

    def __init__(self, rtype, nodes=None, binding=False):
        """Initialize resources.

        Args:
            rtype (ResourcesType): origin of resources
            nodes (list(Node)): list of available nodes
            binding (bool): does information about specific cores is available
        """
        self._type = rtype
        self._binding = binding

        self._nodes = nodes
        if self._nodes is None:
            self._nodes = []

        for node in self._nodes:
            node.resources = self

        self._total_cores = 0
        self._used_cores = 0

        self._max_crs = dict()
        self._total_crs = dict()

        self._compute_resource_status()

        self._system_allocation = None

    def _compute_resource_status(self):
        """Create total view of available resource.
        Based on node information the:
            * total number of cores
            * number of used cores
            * total number of crs
            * maximum number of crs on nodes
        are computed.
        """
        total, used = 0, 0
        self._max_crs = dict()
        self._total_crs = dict()
        for node in self._nodes:
            total += node.total
            used += node.used

            if node.crs:
                for cr, value in node.crs.items():
                    if cr not in self._max_crs or value.available > self._max_crs[cr]:
                        self._max_crs[cr] = value.available

                    self._total_crs[cr] = self._total_crs.get(cr, 0) + value.available

        self._total_cores = total
        self._used_cores = used

    @property
    def rtype(self):
        """ResourceType: type of resources"""
        return self._type

    @property
    def binding(self):
        """bool: is cpu binding available"""
        return self._binding

    @property
    def nodes(self):
        """list(Node): list of all available nodes"""
        return self._nodes

    @property
    def total_nodes(self):
        """int: total number of nodes"""
        return len(self._nodes)

    @property
    def total_cores(self):
        """int: total number of available cores"""
        return self._total_cores

    @property
    def used_cores(self):
        """int: number of used cores"""
        return self._used_cores

    @property
    def free_cores(self):
        """int: number of currently free cores"""
        return self._total_cores - self._used_cores

    @property
    def max_crs(self):
        """dict(CRType,int): maximum number of CRs on a single node"""
        return self._max_crs

    @property
    def total_crs(self):
        """dict(CRType,int): total number of CRs on all nodes"""
        return self._total_crs

    def mark_not_available_cores(self, not_avail_cores):
        self._used_cores += not_avail_cores
        _logger.info(f'marking {not_avail_cores} as non available - current free cores {self.free_cores}/{self.total_cores}')

    def mark_available_cores(self, avail_cores):
        self._used_cores -= avail_cores
        _logger.info(f'marking {avail_cores} as available - current free cores {self.free_cores}/{self.total_cores}')

    def allocate_for_system(self):
        """Allocate single core for QCG-PilotJob, excluding this core from those available for jobs."""
        if self._system_allocation:
            self._system_allocation.release()

            self._system_allocation = None

        for node in self._nodes:
            self._system_allocation = node.allocate_exact(1)

            if self._system_allocation:
                break

    def node_cores_allocated(self, cores):
        """Function called by the node when some cores has been allocated.

        This function should track number of used cores in Resources statistics.

        Args:
            cores (int): number of allocated cores
        """
        self._used_cores += cores

    def node_cores_released(self, cores):
        """Function called by the node when some cores has been released.
        This function should track number of used cores in Resources statistics.

        Args:
            cores (int): number of released cores
        """
        self._used_cores -= cores

    def __str__(self):
        """Return string representation of resources.

        Returns:
            str: string representation of resources
        """
        header = '{} ({} used) cores on {} nodes, options ({})\n'.format(
            self._total_cores, self._used_cores, len(self._nodes), 'binding={}'.format(self._binding))
        return header + '\n'.join([str(node) for node in self._nodes])

    def check_min_job_requirements(self, job_reqs):
        """Check if given resource requirements can be met with those available.

        Args:
            job_reqs (job_reqs): job's resource requirements described as dictionary

        Returns:
            bool: true if job's resources requirements are less than available
        """
        if job_reqs.has_nodes:
            min_nodes = job_reqs.nodes.exact if job_reqs.nodes.is_exact() else job_reqs.nodes.min

            if min_nodes > self.total_nodes:
                # not enough nodes
                _logger.info('Not enough nodes')
                return False

            if job_reqs.has_cores:
                min_cores = job_reqs.cores.exact if job_reqs.cores.is_exact() else job_reqs.cores.min

                found_nodes = 0
                for node in self.nodes:
                    if node.total >= min_cores:
                        found_nodes += 1
                        if found_nodes >= min_nodes:
                            break

                if found_nodes < min_nodes:
                    # not enough cores on nodes
                    _logger.info('Not enough suitable nodes')
                    return False

        if job_reqs.get_min_num_cores() > self.total_cores:
            _logger.info('Not enough total cores')
            return False

        return True

    def to_dict(self):
        """Serialize resources information to dictionary.

        Returns:
            dict: serialized resources information
        """
        return {'type': self._type.name, 'nodes': [node.to_dict() for node in self._nodes],
                'binding': self._binding}

    def to_json(self):
        """"Serialize resources information to JSON.

        Returns:
            str: serialized resources information
        """
        return json.dumps(self.to_dict())

    @staticmethod
    def from_dict(data):
        """Create instance of Resources class based on serialized data.

        Args:
            data: resources data generated by the 'to_dict' method

        Returns:
            Resources: instance of Resources class
        """
        return Resources(ResourcesType[data['type']], [Node.from_dict(nData) for nData in data['nodes']],
                         data['binding'])
